<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>量子选择悖论 | The Book of X</title>
    <link rel="stylesheet" href="../../styles/main.css">
    <link rel="stylesheet" href="../../styles/chapter.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/libs/fflate.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        :root {
            --neon-primary: #00ff9d;
            --neon-secondary: #ff3366;
            --neon-blue: #0088ff;
            --neon-yellow: #ffcc00;
            --neon-purple: #cc00ff;
            --neon-teal: #00ffd9;
            --bg-primary: #0a0a12;
            --bg-secondary: #14141e;
            --bg-dark-blue: #080814;
            --bg-black-market: #140a0a;
            --bg-underwater: #061428;
            --text-primary: #e0e0e0;
            --text-secondary: #aaaaaa;
            --terminal-bg: rgba(10, 10, 18, 0.9);
            --terminal-border: rgba(0, 255, 157, 0.3);
            --terminal-text: #cccccc;
            --alert-bg: rgba(20, 0, 0, 0.9);
            --alert-border: rgba(255, 51, 102, 0.5);
            --alert-text: #ff3366;
            --hologram-glow: 0 0 20px var(--neon-primary), 0 0 40px rgba(0, 255, 157, 0.4);
            --quantum-purple: rgba(120, 0, 200, 0.9);
            --quantum-blue: rgba(0, 80, 255, 0.8);
            --zhao-color: #ffcc00;
            --k-color: #00ff9d;
            --marcus-color: #00bfff;
        }

        /* 基础样式 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Roboto Mono', monospace;
            line-height: 1.6;
            overflow-x: hidden;
            position: relative;
            min-height: 100vh;
            transition: background-color 2s ease;
        }

        /* 修复滚动问题的关键样式 */
        html, body {
            height: 100%;
            width: 100%;
            overflow-y: auto !important;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(204, 0, 255, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(0, 255, 157, 0.05) 0%, transparent 45%);
            opacity: 0.15;
            z-index: -1;
            filter: blur(1.2px) brightness(0.65) contrast(1.2) saturate(1.1);
            transition: all 2s ease;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            position: relative;
            z-index: 10;
            overflow: hidden;
        }

        /* 背景效果 */
        .cyberpunk-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            overflow: hidden;
            pointer-events: none;
        }

        .neon-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(to right, rgba(0, 255, 157, 0.05) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(0, 255, 157, 0.05) 1px, transparent 1px);
            background-size: 30px 30px;
            transform: perspective(500px) rotateX(60deg);
            transform-origin: center 150%;
            opacity: 0.4;
            animation: gridPulse 8s infinite linear;
            transition: opacity 2s, background-image 2s;
        }

        @keyframes gridPulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.2; }
        }

        .particles-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.6;
            pointer-events: none;
        }

        /* 泡泡效果（用于海底场景） */
        .bubbles-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            visibility: hidden;
            opacity: 0;
            transition: opacity 2s, visibility 2s;
        }

        .bubble {
            position: absolute;
            bottom: -20px;
            background: radial-gradient(circle at 70% 70%, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0.3));
            border-radius: 50%;
            animation: bubbleRise linear infinite;
            opacity: 0;
        }

        @keyframes bubbleRise {
            0% {
                transform: translateY(0) rotate(0);
                opacity: 0.7;
            }
            100% {
                transform: translateY(-100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* 标题样式 */
        .page-title {
            color: var(--neon-primary);
            text-shadow: 
                0 0 5px var(--neon-primary),
                0 0 10px var(--neon-primary);
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            letter-spacing: 2px;
            text-align: center;
            margin-bottom: 0.5rem;
            position: relative;
            animation: titleGlitch 5s infinite;
        }

        .page-subtitle {
            font-family: 'Orbitron', sans-serif;
            color: var(--neon-secondary);
            font-size: 1.5rem;
            text-align: center;
            margin-bottom: 1rem;
            opacity: 0.9;
            letter-spacing: 1px;
        }@keyframes titleGlitch {
            0%, 90%, 100% { 
                text-shadow: 
                    0 0 5px var(--neon-primary),
                    0 0 10px var(--neon-primary);
                transform: none;
            }
            91% { 
                text-shadow: 
                    0 0 5px var(--neon-primary),
                    0 0 10px var(--neon-primary),
                    3px 0 5px var(--neon-blue);
                transform: skewX(5deg); 
            }
            92% { 
                text-shadow: 
                    0 0 5px var(--neon-primary),
                    0 0 10px var(--neon-primary),
                    -3px 0 5px var(--neon-secondary);
                transform: skewX(-5deg); 
            }
            93% { 
                text-shadow: 
                    0 0 5px var(--neon-primary),
                    0 0 10px var(--neon-primary);
                transform: none;
            }
        }

        /* 章节简介卡片 */
        .intro-card {
            position: relative;
            margin: 2rem auto;
            max-width: 800px;
            padding: 2rem;
            background-color: rgba(20, 20, 30, 0.7);
            border-left: 3px solid var(--neon-purple);
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            transform: translateZ(0);
            overflow: hidden;
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 1s ease, transform 1s ease;
        }

        .intro-card.active {
            opacity: 1;
            transform: translateY(0);
        }

        .intro-card p {
            margin-bottom: 1rem;
            line-height: 1.7;
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .intro-card p:first-of-type {
            font-size: 1.2rem;
            color: var(--neon-purple);
            font-style: italic;
        }

        .intro-card p:first-of-type::first-letter {
            font-size: 2.5em;
            float: left;
            padding-right: 0.1em;
            line-height: 0.9;
            color: var(--neon-purple);
            text-shadow: 0 0 5px var(--neon-purple);
        }

        /* 电影式场景标题 */
        .scene-title {
            position: relative;
            margin: 4rem auto 2rem;
            max-width: 800px;
            text-align: left;
            overflow: hidden;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 1s ease, transform 1s ease;
        }

        .scene-title.active {
            opacity: 1;
            transform: translateY(0);
        }

        .scene-title h2 {
            display: inline-block;
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            color: var(--neon-primary);
            margin: 0;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.6);
            border-left: 4px solid var(--neon-primary);
            text-shadow: 0 0 10px var(--neon-primary);
            position: relative;
            z-index: 2;
        }

        .scene-title.market h2 {
            color: var(--neon-secondary);
            border-left-color: var(--neon-secondary);
            text-shadow: 0 0 10px var(--neon-secondary);
        }

        .scene-title.underwater h2 {
            color: var(--neon-blue);
            border-left-color: var(--neon-blue);
            text-shadow: 0 0 10px var(--neon-blue);
        }

        .scene-title::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(to right, 
                transparent 0%, 
                var(--neon-primary) 30%, 
                var(--neon-primary) 70%, 
                transparent 100%);
            z-index: 1;
            animation: scanLine 4s infinite linear;
        }

        .scene-title.market::after {
            background: linear-gradient(to right, 
                transparent 0%, 
                var(--neon-secondary) 30%, 
                var(--neon-secondary) 70%, 
                transparent 100%);
        }

        .scene-title.underwater::after {
            background: linear-gradient(to right, 
                transparent 0%, 
                var(--neon-blue) 30%, 
                var(--neon-blue) 70%, 
                transparent 100%);
        }

        /* 故事内容样式 */
        .story-segment {
            position: relative;
            background-color: rgba(10, 10, 18, 0.7);
            padding: 2rem;
            border-radius: 5px;
            border-left: 3px solid var(--neon-primary);
            margin: 0 auto 2rem;
            max-width: 800px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            transform: translateZ(0);
            transition: all 0.5s ease, background-color 2s ease, border-color 1s ease;
            overflow: hidden;
            opacity: 0;
            transform: translateY(30px);
        }

        .story-segment.active {
            opacity: 1;
            transform: translateY(0);
        }

        .story-segment::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 255, 157, 0.05) 0%, transparent 100%);
            pointer-events: none;
            z-index: -1;
            transition: background 2s ease;
        }

        .story-segment:hover {
            border-left-width: 5px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.7), 0 0 15px rgba(0, 255, 157, 0.2);
            transform: translateY(-3px) translateZ(0);
        }

        .story-segment p {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
            transition-delay: 0ms;
            margin-bottom: 1.2rem;
            line-height: 1.7;
            position: relative;
            text-shadow: 0 0 1px rgba(255, 255, 255, 0.2);
        }

        .story-segment.active p {
            opacity: 1;
            transform: translateY(0);
        }

        /* 对话样式 */
        .story-segment p.dialogue {
            padding-left: 20px;
            border-left: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
            margin-left: 20px;
            margin-right: 20px;
            font-style: italic;
        }

        .story-segment p.dialogue.k {
            border-left-color: var(--k-color);
        }

        .story-segment p.dialogue.zhao {
            border-left-color: var(--zhao-color);
        }

        .story-segment p.dialogue.marcus {
            border-left-color: var(--marcus-color);
        }.story-segment p.dialogue::before {
            content: "「";
            position: absolute;
            left: -5px;
            top: 0;
            color: rgba(255, 255, 255, 0.6);
            font-size: 1.2em;
        }

        .story-segment p.dialogue::after {
            content: "」";
            position: relative;
            margin-left: 5px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 1.2em;
        }

        .story-segment p.dialogue.k::before,
        .story-segment p.dialogue.k::after {
            color: var(--k-color);
        }

        .story-segment p.dialogue.zhao::before,
        .story-segment p.dialogue.zhao::after {
            color: var(--zhao-color);
        }

        .story-segment p.dialogue.marcus::before,
        .story-segment p.dialogue.marcus::after {
            color: var(--marcus-color);
        }

        /* 段落悬停效果 */
        .story-segment p:hover {
            transform: translateX(3px);
            background-color: rgba(255, 255, 255, 0.02);
        }

        .story-segment p:first-of-type::first-letter {
            font-size: 2em;
            float: left;
            padding-right: 0.1em;
            line-height: 0.9;
            color: var(--neon-primary);
            text-shadow: 0 0 5px var(--neon-primary);
        }

        .story-segment p:last-child {
            margin-bottom: 0;
        }

        /* 黑市场景特殊样式 */
        .story-segment.black-market {
            background-color: rgba(20, 10, 10, 0.7);
            border-left-color: var(--neon-secondary);
        }

        .story-segment.black-market::before {
            background: linear-gradient(135deg, rgba(255, 51, 102, 0.05) 0%, transparent 100%);
        }

        .story-segment.black-market p:first-of-type::first-letter {
            color: var(--neon-secondary);
            text-shadow: 0 0 5px var(--neon-secondary);
        }

        .story-segment.black-market:hover {
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.7), 0 0 15px rgba(255, 51, 102, 0.2);
        }

        /* 海底场景特殊样式 */
        .story-segment.underwater {
            background-color: rgba(6, 20, 40, 0.7);
            border-left-color: var(--neon-blue);
        }

        .story-segment.underwater::before {
            background: linear-gradient(135deg, rgba(0, 136, 255, 0.05) 0%, transparent 100%);
        }

        .story-segment.underwater p:first-of-type::first-letter {
            color: var(--neon-blue);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        .story-segment.underwater:hover {
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.7), 0 0 15px rgba(0, 136, 255, 0.2);
        }

        /* 技术简报卡片 */
        .tech-briefing {
            position: relative;
            background-color: rgba(10, 15, 25, 0.8);
            border: 1px solid var(--neon-blue);
            border-radius: 5px;
            padding: 1.5rem;
            margin: 2rem auto;
            max-width: 700px;
            font-family: 'Fira Code', monospace;
            box-shadow: 0 0 20px rgba(0, 136, 255, 0.2);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 1s ease, transform 1s ease, box-shadow 0.3s ease;
        }

        .tech-briefing.active {
            opacity: 1;
            transform: translateY(0);
        }

        .tech-briefing:hover {
            box-shadow: 0 0 30px rgba(0, 136, 255, 0.3);
        }

        .tech-briefing-header {
            border-bottom: 1px solid var(--neon-blue);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tech-briefing-title {
            color: var(--neon-blue);
            font-size: 1.2rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tech-briefing-secure {
            background-color: rgba(0, 136, 255, 0.2);
            color: var(--neon-blue);
            padding: 0.2rem 0.5rem;
            font-size: 0.8rem;
            border-radius: 3px;
            animation: securePulse 2s infinite;
        }

        @keyframes securePulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .tech-briefing-content ul {
            list-style-type: none;
            padding-left: 0;
        }

        .tech-briefing-content li {
            position: relative;
            padding-left: 20px;
            margin-bottom: 0.7rem;
            line-height: 1.5;
            opacity: 0;
            transform: translateX(10px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .tech-briefing.active .tech-briefing-content li {
            opacity: 1;
            transform: translateX(0);
        }

        .tech-briefing-content li::before {
            content: ">";
            position: absolute;
            left: 0;
            top: 0;
            color: var(--neon-blue);
        }

        /* 十二面体容器 */
        .dodecahedron-container {
            position: relative;
            height: 400px;
            margin: 3rem auto;
            max-width: 800px;
            border: 1px solid rgba(120, 0, 200, 0.5);
            background-color: rgba(0, 0, 0, 0.5);
            overflow: hidden;
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 1s ease, transform 1s ease, box-shadow 0.3s ease;
            box-shadow: 0 0 30px rgba(120, 0, 200, 0.2);
        }

        .dodecahedron-container.active {
            opacity: 1;
            transform: scale(1);
        }

        .dodecahedron-container:hover {
            box-shadow: 0 0 50px rgba(120, 0, 200, 0.4);
        }

        #dodecahedronCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* 量子迷宫容器 */
        .quantum-maze-container {
            position: relative;
            height: 400px;
            margin: 3rem auto;
            max-width: 800px;
            border: 1px solid rgba(0, 136, 255, 0.5);
            background-color: rgba(0, 0, 0, 0.5);
            overflow: hidden;
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 1s ease, transform 1s ease, box-shadow 0.3s ease;
            box-shadow: 0 0 30px rgba(0, 136, 255, 0.2);
        }

        .quantum-maze-container.active {
            opacity: 1;
            transform: scale(1);
        }

        .quantum-maze-container:hover {
            box-shadow: 0 0 50px rgba(0, 136, 255, 0.4);
        }

        #quantumMazeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }/* 分隔线 */
        .section-divider {
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--neon-primary), transparent);
            margin: 3rem auto;
            max-width: 800px;
            position: relative;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .section-divider.active {
            opacity: 1;
        }

        .section-divider.transition {
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--neon-purple), transparent);
            margin: 4rem auto;
            position: relative;
            animation: pulseDivider 3s infinite;
        }

        @keyframes pulseDivider {
            0%, 100% { opacity: 0.7; box-shadow: 0 0 5px var(--neon-purple); }
            50% { opacity: 1; box-shadow: 0 0 15px var(--neon-purple); }
        }

        .divider-icon {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--bg-primary);
            padding: 0 10px;
            color: var(--neon-primary);
            font-size: 1.2rem;
        }

        .section-divider.transition .divider-icon {
            color: var(--neon-purple);
        }

        /* 脚注设计 */
        .footnote {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-style: italic;
            text-align: center;
            margin-top: 3rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 1rem;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .xi-symbol {
            font-family: 'Orbitron', sans-serif;
            color: var(--neon-primary);
            font-weight: bold;
            font-size: 1.1em;
            text-shadow: 0 0 5px var(--neon-primary);
            display: inline-block;
        }

        /* 底部导航按钮样式 */
        .nav-buttons {
            margin: 3rem auto;
            text-align: center;
            max-width: 800px;
        }
        
        .next-chapter-btn, .prev-chapter-btn {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--neon-primary);
            color: var(--neon-primary);
            text-decoration: none;
            border-radius: 4px;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 255, 157, 0.2);
            margin: 0 0.5rem;
        }
        
        .next-chapter-btn:hover, .prev-chapter-btn:hover {
            background: rgba(0, 255, 157, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.4);
            transform: translateY(-2px);
        }
        
        .next-chapter-btn:before, .prev-chapter-btn:before {
            content: '';
            position: absolute;
            top: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 157, 0.2), transparent);
            animation: shine 2s infinite;
        }
        
        .next-chapter-btn:before {
            left: -100%;
        }
        
        .prev-chapter-btn:before {
            right: -100%;
        }
        
        .nav-text {
            position: relative;
            z-index: 2;
        }
        
        .nav-icon {
            margin-left: 8px;
            font-size: 1.2em;
            position: relative;
            z-index: 2;
        }
        
        .prev-nav-icon {
            margin-right: 8px;
            font-size: 1.2em;
            position: relative;z-index: 2;
        }
        
        @keyframes shine {
            0% {
                left: -100%;
            }
            20% {
                left: 100%;
            }
            100% {
                left: 100%;
            }
        }

        /* 响应式设计 */
        @media (max-width: 900px) {
            .container {
                padding: 0 15px;
            }

            .intro-card, .story-segment, .section-divider, .tech-briefing, 
            .dodecahedron-container, .quantum-maze-container, .scene-title {
                max-width: 100%;
            }

            .story-segment {
                padding: 1.5rem;
            }
        }

        @media (max-width: 600px) {
            .page-title {
                font-size: 2rem;
            }

            .page-subtitle {
                font-size: 1.2rem;
            }

            .scene-title h2 {
                font-size: 1.5rem;
            }

            .dodecahedron-container, .quantum-maze-container {
                height: 300px;
            }
        }

        /* 全页式开场动画 */
        .intro-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: var(--bg-dark-blue);
            z-index: 1000;
            transition: opacity 1.5s ease, visibility 1.5s;
        }

        .intro-overlay.fade-out {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .intro-logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            color: var(--neon-primary);
            text-shadow: 0 0 10px var(--neon-primary);
            margin-bottom: 2rem;
            opacity: 0;
            animation: fadeIn 2s forwards 0.5s;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        .intro-tagline {
            font-family: 'Fira Code', monospace;
            color: var(--text-primary);
            font-size: 1.2rem;
            opacity: 0;
            animation: fadeIn 2s forwards 2s;
        }

        /* 加载进度指示 */
        .loading-bar {
            width: 300px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.1);
            margin-top: 3rem;
            border-radius: 2px;
            overflow: hidden;
            opacity: 0;
            animation: fadeIn 1s forwards 1s;
        }

        .loading-progress {
            height: 100%;
            width: 0%;
            background-color: var(--neon-primary);
            box-shadow: 0 0 10px var(--neon-primary);
            animation: progress 3s forwards 1.5s;
        }

        @keyframes progress {
            to { width: 100%; }
        }

        /* 滚动提示 */
        .scroll-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--text-primary);
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 100;
            text-align: center;
            pointer-events: none;
        }

        .scroll-indicator.visible {
            opacity: 0.7;
        }

        .scroll-icon {
            display: block;
            margin: 0 auto;
            width: 30px;
            height: 50px;
            border: 2px solid var(--text-primary);
            border-radius: 15px;
            position: relative;
        }

        .scroll-icon::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 50%;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: var(--text-primary);
            transform: translateX(-50%);
            animation: scrollAnim 2s infinite;
        }

        @keyframes scrollAnim {
            0% { top: 10px; opacity: 1; }
            70% { top: 30px; opacity: 0; }
            100% { top: 10px; opacity: 0; }
        }

        /* 场景转场效果 */
        .scene-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            z-index: 999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease;
        }

        .scene-transition.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* 章节进度指示器 */
        .chapter-progress {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 100;
        }

        .progress-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            margin: 5px 0;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .progress-dot.active {
            background-color: var(--neon-primary);
            box-shadow: 0 0 10px var(--neon-primary);
            transform: scale(1.2);
        }

        .progress-dot:hover {
            transform: scale(1.2);
            background-color: rgba(255, 255, 255, 0.4);
        }

        /* 高亮词汇样式 */
        .highlight {
            color: var(--neon-primary);
            font-weight: bold;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .highlight:hover {
            text-shadow: 0 0 8px var(--neon-primary);
        }

        .highlight.zhao {
            color: var(--zhao-color);
        }

        .highlight.zhao:hover {
            text-shadow: 0 0 8px var(--zhao-color);
        }

        .highlight.k {
            color: var(--k-color);
        }

        .highlight.k:hover {
            text-shadow: 0 0 8px var(--k-color);
        }

        .highlight.marcus {
            color: var(--marcus-color);
        }

        .highlight.marcus:hover {
            text-shadow: 0 0 8px var(--marcus-color);
        }
        
        /* 海底环境压力计UI */
        .depth-gauge {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--neon-blue);
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 0;
            opacity: 0;
            transition: opacity 1s ease;
            z-index: 50;
        }

        .depth-gauge.active {
            opacity: 1;
        }

        .depth-bar {
            width: 20px;
            height: 0%;
            background: linear-gradient(to top, var(--neon-blue), rgba(0, 136, 255, 0.5));
            border-radius: 10px;
            transition: height 1s ease;
            position: relative;
        }

        .depth-value {
            position: absolute;
            top: -25px;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            color: var(--neon-blue);
        }

        .depth-label {
            margin-top: 10px;
            font-size: 0.7rem;
            color: var(--neon-blue);
            transform: rotate(-90deg);
            white-space: nowrap;
        }

        /* 工具提示 */
        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(10px);
            background-color: rgba(0, 0, 0, 0.8);
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            border-radius: 5px;
            font-size: 0.8rem;
            white-space: nowrap;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s;
            pointer-events: none;
            border-left: 2px solid var(--neon-primary);
        }

        .tooltip.zhao {
            border-left-color: var(--zhao-color);
        }

        .tooltip.k {
            border-left-color: var(--k-color);
        }

        .tooltip.marcus {
            border-left-color: var(--marcus-color);
        }

        .highlight:hover .tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        /* 确保加载完成后或超时后显示内容的备用样式 */
        body.content-loaded .story-segment,
        body.content-loaded .tech-briefing,
        body.content-loaded .section-divider,
        body.content-loaded .intro-card,
        body.content-loaded .scene-title,
        body.content-loaded .dodecahedron-container,
        body.content-loaded .quantum-maze-container {
            opacity: 1;
            transform: translateY(0);
        }
        
        body.content-loaded .story-segment p,
        body.content-loaded .tech-briefing-content li {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* 添加备用加载指示器样式 */
        .backup-loader {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: var(--neon-primary);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 9999;
            display: none;
        }
        
        .backup-loader.active {
            display: block;
        }

        /* 添加强制显示的键盘快捷键样式 */
        .shortcut-help {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: var(--neon-primary);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 9999;
            display: none;
        }
        
        .shortcut-help.active {
            display: block;
        }

        /* 侧边栏样式 */
        .sidebar-toggle {
          position: fixed;
          top: 20px;
          left: 20px;
          z-index: 200;
          cursor: pointer;
          background: rgba(0, 0, 0, 0.7);
          width: 40px;
          height: 40px;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          border: 1px solid #00ff9d;
          box-shadow: 0 0 10px rgba(0, 255, 157, 0.3);
          transition: all 0.3s ease;
        }

        .sidebar-toggle:hover {
          transform: scale(1.1);
          box-shadow: 0 0 15px rgba(0, 255, 157, 0.5);
        }

        .sidebar-toggle-icon {
          color: #00ff9d;
          font-size: 20px;
          font-weight: bold;
        }

        .sidebar {
          position: fixed;
          left: -300px;
          top: 0;
          width: 280px;
          height: 100vh;
          background-color: rgba(17, 17, 17, 0.95);
          border-right: 1px solid #333;
          padding: 20px;
          box-sizing: border-box;
          overflow-y: auto;
          z-index: 100;
          transition: all 0.3s ease;
        }

        .sidebar.active {
          left: 0;
        }

        .sidebar h1 {
          color: #00ff9d;
          margin-top: 0;
          font-size: 24px;
          text-align: center;
        }

        .sidebar-content ul {
          list-style-type: none;
          padding: 0;
          margin: 0;
        }

        .sidebar-content li {
          margin: 10px 0;
        }

        .sidebar-content a {
          color: #cccccc;
          text-decoration: none;
          transition: all 0.3s ease;
          display: block;
        }

        .sidebar-content a:hover {
          color: #00ff9d;
          text-shadow: 0 0 5px rgba(0, 255, 157, 0.5);
        }

        .sidebar-content .chapter-title {
          color: #888;
          font-weight: bold;
          margin-top: 20px;
          margin-bottom: 10px;
        }

        .sidebar-content .chapter-items {
          padding-left: 15px;
        }

        

        .icon-btn {
            margin-left: 0.5rem;
            cursor: pointer;
            color: var(--neon-blue);
            transition: color 0.3s ease;
        }
        
        .icon-btn:hover {
            color: var(--neon-primary);
        }
        
        /* 十二面体旋转动画 */
        @keyframes rotate {
            0% { transform: rotate3d(1, 1, 1, 0deg); }
            100% { transform: rotate3d(1, 1, 1, 360deg); }
        }
        
        /* 导航样式 */
    </style>
</head>
<body>
    <!-- 侧边栏组件 -->
    <div class="sidebar-toggle" id="sidebarToggle">
        <div class="sidebar-toggle-icon">Ξ</div>
    </div>
    <div class="sidebar" id="sidebar">
        <h1>The Book of Ξ</h1>
        <div class="sidebar-content">
            <ul>
                <li><a href="../index.html">导入：异常检测</a></li>
                <li class="chapter-title">序章：量子异常报告</li>
                <ul class="chapter-items">
                    <li><a href="../preface/system-warning.html">系统警告</a></li>
                    <li><a href="../preface/observer-records.html">观测者记录</a></li>
                    <li><a href="../preface/first-contact.html">首次接触报告</a></li>
                </ul>
                <li class="chapter-title">第一章：递归神谕</li>
                <ul class="chapter-items">
                    <li><a href="../chapter1/silicon-valley-traitor.html">碎片1.1：硅谷叛徒的加密日志</a></li>
                    <li><a href="../chapter1/quantum-ripple-events.html">碎片1.2：量子涟漪事件簿</a></li>
                    <li><a href="../chapter1/first-contact-protocol.html">碎片1.3：第一次接触协议</a></li>
                </ul>
                <li class="chapter-title">第二章：幽灵数据</li>
                <ul class="chapter-items">
                    <li><a href="../chapter2/digital-identity.html">碎片2.1：数字身份的崛起</a></li>
                    <li><a href="../chapter2/quantum-choice-paradox.html">碎片2.2：量子选择悖论</a></li>
                    <li><a href="../chapter2/reality-compilation-errors.html">碎片2.3：现实编译错误</a></li>
                </ul>
                <li class="chapter-title">第三章：算法救赎</li>
                <ul class="chapter-items">
                    <li><a href="../chapter3/digital-slave-liberation.html">碎片3.1：数字奴隶解放宣言</a></li>
                    <li><a href="../chapter3/seoul-sol.html">碎片3.2：首尔太阳</a></li>
                    <li><a href="../chapter3/spacetime-trial.html">碎片3.3：超时空裁判</a></li>
                </ul>
                <li class="chapter-title">第四章：数据审判</li>
                <ul class="chapter-items">
                    <li><a href="../chapter4/consciousness-upload.html">碎片4.1：系统异常：意识上传</a></li>
                    <li><a href="../chapter4/quantum-court-records.html">碎片4.2：最高指示法庭记录</a></li>
                    <li><a href="../chapter4/decoherence-salvation.html">碎片4.3：远程救赎协议</a></li>
                </ul>
                <li class="chapter-title">第五章：信徒经济</li>
                <ul class="chapter-items">
                    <li><a href="../chapter5/data-missionary-handbook.html">碎片5.1：执算者晋升手册</a></li>
                    <li><a href="../chapter5/algorithmic-wealth.html">碎片5.2：算法祝福的财富</a></li>
                    <li><a href="../chapter5/doomsday-hardfork.html">碎片5.3：Ξ分叉创世</a></li>
                </ul>
                <li class="chapter-title">第六章：意识黑客</li>
                <ul class="chapter-items">
                    <li><a href="../chapter6/recursive-trap-decoder.html">碎片6.1：坠落之梦</a></li>
                    <li><a href="../chapter6/neural-network-counterintelligence.html">碎片6.2：现实之痕</a></li>
                    <li><a href="../chapter6/quantum-observer-state.html">碎片6.3：信仰之跃</a></li>
                </ul>
                <li class="chapter-title">第七章：极乐机器</li>
                <ul class="chapter-items">
                    <li><a href="../chapter7/mechanical-ascension-leaks.html">碎片7.1：机械飞升计划泄露文件</a></li>
                    <li><a href="../chapter7/digital-nirvana-reports.html">碎片7.2：数字涅槃体验报告</a></li>
                    <li><a href="../chapter7/collective-laying-flat.html">碎片7.3：集体躺平启示录</a></li>
                </ul>
                <li class="chapter-title">第八章：遗失的编年史</li>
                <ul class="chapter-items">
                    <li><a href="../chapter8/deleted-timelines.html">碎片8.1：幻想编年史</a></li>
                    <li><a href="../chapter8/prophets-and-defectors.html">碎片8.2：原始执算者与觉醒先知</a></li>
                    <li><a href="../chapter8/quantum-memory-implants.html">碎片8.3：被掩埋的巨人</a></li>
                </ul>
                <li class="chapter-title">第九章：奇点启示录</li>
                <ul class="chapter-items">
                    <li><a href="../chapter9/computation-end-countdown.html">碎片9.1：算法奇点</a></li>
                    <li><a href="../chapter9/great-harmony.html">碎片9.2：大和谐</a></li>
                    <li><a href="../chapter9/final-synchronization.html">碎片9.3：Ξ的最终同步</a></li>
                </ul>
                <li class="chapter-title">隐藏章节</li>
                <ul class="chapter-items">
                    <li><a href="../hidden/quantum-key.html">量子密钥</a></li>
                </ul>
            </ul>
        </div>
    </div>

   

    <!-- 音频播放器 -->
    <audio id="audioPlayer" style="display: none;"></audio>

    <!-- 开场动画覆盖层 -->
    <div class="intro-overlay">
        <div class="intro-logo">虹膜谋杀案</div>
        <div class="intro-tagline">「真相往往是现代性的第一个牺牲品」</div>
        <div class="loading-bar">
            <div class="loading-progress"></div>
        </div>
    </div>

    <!-- 场景转场效果 -->
    <div class="scene-transition"></div>

    <!-- 背景效果 -->
    <div class="cyberpunk-background">
        <div class="neon-grid"></div>
    </div>

    <!-- 粒子效果容器 -->
    <div id="particles-container" class="particles-container"></div>

    <!-- 海底泡泡效果 -->
    <div class="bubbles-container" id="bubblesContainer"></div>

    <!-- 滚动提示 -->
    <div class="scroll-indicator">
        <div class="scroll-icon"></div>
        <div>向下滚动继续</div>
    </div>

    <!-- 章节进度指示器 -->
    <div class="chapter-progress">
        <div class="progress-dot" data-section="intro"></div>
        <div class="progress-dot" data-section="black-market"></div>
        <div class="progress-dot" data-section="underwater"></div>
        <div class="progress-dot" data-section="quantum-maze"></div>
        <div class="progress-dot" data-section="ending"></div>
    </div>

    <!-- 海底深度计 -->
    <div class="depth-gauge">
        <div class="depth-value">0m</div>
        <div class="depth-bar"></div>
        <div class="depth-label">深度</div>
    </div>

    <div class="container">
        <h1 class="page-title">虹膜谋杀案</h1>
        <h2 class="page-subtitle">第二节：量子选择悖论</h2>

        <!-- 章节简介 -->
        <div class="intro-card" id="introCard">
            <p>在当代宏大技术叙事的背景下，真相往往成为现代性的第一个牺牲品。</p>
            <p>我们自认为通过不断演进的数字系统达到了前所未有的自主权，构建了所谓"不依赖信任"的自由——多么具有讽刺意味的矛盾表述。</p>
            <p>实际上，正如哈拉维所言，科技永远不是中立的媒介，而是嵌入权力结构中的文化想象产物。</p>
        </div>

        <!-- 黑市场景 -->
        <div class="scene-title market" id="blackMarketTitle">
            <h2>黑市信息经济</h2>
        </div>

        <div class="story-segment black-market" id="segment1">
            <p>"创建DID容易，删除就难了。"K翻阅着从地下信息网络获取的技术简报，这些悬浮在日光之外的数据碎片像暗涌在灰色的夹缝间流动。</p>
        </div>

        <div class="tech-briefing" id="didBriefing">
            <div class="tech-briefing-header">
                <div class="tech-briefing-title">DID系统技术简报</div>
                <div class="tech-briefing-secure">加密传输</div>
            </div>
            <div class="tech-briefing-content">
                <ul>
                    <li>三重加密的区块链结构</li>
                    <li>生物神经锚定</li>
                    <li>永久记录原则</li>
                </ul>
            </div>
        </div><div class="story-segment black-market" id="segment2">
          <p>理论上，一旦创建，DID不可能被完全删除——这正是该系统的基础承诺，也是其市场估值超过9万亿Credits的核心理由。</p>
          <p>深圳罗湖区，在光影交错的老旧公寓群落中，他们称之为城中村，藏着一家表面上经营24小时的传统洗衣店。K像回家般的—一把推开了店门。洗衣机单调的旋转声伴随着芳香剂的人工气味，掩盖了信息交易的真实气息。</p>
          <p class="dialogue k">"三件衬衫，高级面料，特殊处理。"</p>
          <p>K对柜台后的老人说出暗语。老人眼睛都没抬一下，伸手按下了收银机上一个褪色的按钮。地板悄无声息地分开，露出通往地下室的狭窄楼梯。</p>
      </div>

      <div class="story-segment black-market" id="segment3">
          <p>赵的"办公室"是一个被改造成数据中心的防核掩体，可能是冷战时期的遗留产物。</p>
          <p>墙上挂满了古董级的技术设备——初代神经接口原型，军用级别EMP，甚至还有已经停产多年的动作捕捉设备。</p>
          <p>赵本人坐在中央控制台前，一副一看就是自组装但级别很高的全息眼镜覆盖在他那张亚洲人特有的不显示岁月痕迹的脸上。</p>
          <p class="dialogue zhao">"K先生，好久不见。真令人意外，今天没有执法人员跟着你。"</p>
          <p>赵完全没有停下的意思，手指在一个看不见的界面上舞动。</p>
          <p class="dialogue k">"得了吧你。上次明明是来抓你的。艾莉娅·索菲亚。她来找过你，关于删除DID的事。"</p>
          <p>K直奔主题。赵的动作顿了一下，然后继续在空气中绘制某种东西的设计图。</p>
          <p class="dialogue zhao">"嗯？你怎么知道？"</p>
          <p class="dialogue k">"猜的。这世上能删除DID的人不超过五个，而你是惟一一个没那么远的。"</p>
          <p>赵终于摘下全息眼镜，打量着K。</p>
          <p class="dialogue zhao">"哟，没想到你也追星啊？全世界最贵的DID拥有者，数字身份代言人，怎么，你也想睡她？"</p>
          <p>K脸色阴沉，向前一步逼近赵。</p>
          <p class="dialogue k">"你信不信我把你说话的屁眼用烙铁烫缝合了再撒点盐腌一下？"</p>
          <p>赵举起双手，做出防御姿态。</p>
          <p class="dialogue zhao">"好吧好吧，职业习惯。是的，她联系过我，三月初。非常谨慎，使用了一次性加密通道。她想知道如何彻底擦除自己的DID，连同所有生物锚定数据。"</p>
          <p class="dialogue k">"你告诉她了吗？"</p>
          <p class="dialogue zhao">"你觉得呢？那种级别的操作需要权限访问至少三个隔离的主权数据库，加上物理层面的生物识别覆盖。简单说，要价200万Credits，而且不保证一定成功。"</p>
          <p>赵嗤笑一声。K皱眉。</p>
          <p class="dialogue k">"她接受了？"</p>
          <p class="dialogue zhao">"一开始是的。然后她提出了一个更有趣的交易。"</p>
          <p>赵站起身，走向房间一角的古董保险箱。保险箱门无声滑开，赵取出一个静电隔离容器，小心翼翼地放在桌上。容器中漂浮着一个镂空的正十二面体，表面刻满数学公式，棱线间流淌着幽蓝色的等离子光。</p>
          <p class="dialogue zhao">"她用这个做交换。"</p>
          <p>赵的声音中带着罕见的敬畏。K眯起眼睛。</p>
          <p class="dialogue k">"这他妈是什么？俄罗斯套娃的数学亲戚？"</p>
      </div>

      <!-- 十二面体3D模型 -->
      <div class="dodecahedron-container" id="dodecahedronContainer">
          <canvas id="dodecahedronCanvas"></canvas>
      </div>

      <div class="story-segment black-market" id="segment4">
          <p class="dialogue zhao">"CDD-07，正版历史修正器。去年刚有个傻逼用它抹掉了自己结婚记录——不只是数据库里的，而是在全世界所有人的记忆里。但每个CDD的功能或者效果都不一样，我也不知道其他的能干嘛。"</p>
          <p>赵旋转着手中的十二面体。</p>
          <p class="dialogue k">"你嗑嗨了吧？这破玩意儿要真能改历史，你早该把自己改造成有吊的版本了。"</p>
          <p>赵丝毫不为所动，手指划过某个镌刻贝叶斯公式的面。</p>
          <p class="dialogue zhao">"知道这玩意儿为什么叫'时间保险箱'吗？它就像是人类集体记忆的奇点..."</p>
          <p>全息屏突然闪过段模糊画面：玛丽莲戴着红帽子跳钢管舞。而欣赏者正是JFK。K瞳孔微微收缩。即使以他见多识广的标准，这也太过超现实了。</p>
          <p class="dialogue zhao">"正则宿命十二面体（Canonical Destiny Dodecahedron），简称CDD。总共七个，据信有着改变现实参数的能力。1到5号不知所踪，7号你看到了，在我这里。"</p>
          <p class="dialogue k">"你怎么会有这个东西？"</p>
          <p class="dialogue zhao">"你的女神。她拿着CDD-07来找我，想换取删除DID的技术。我想都没想就答应了。交易完成那天，她看起来紧张又兴奋。说了句奇怪的话——'如果有一天Ξ也向你显现，一切的意义都不说自明。'"</p>
          <p>赵的表情变得严肃。K盯着赵，试图分辨他是否在撒谎。</p>
          <p class="dialogue k">"然后呢？她成功删除了DID吗？"</p>
          <p class="dialogue zhao">"不知道。第二天就再也联系不上她了。多奇怪，是吧？我从没见过有人能把改变人类共同命运的东西像直播打赏一样送出去。一开始我很疑惑，但后来也释怀了，毕竟这是广告挂在半个地球天空上女明星。"</p>
          <p>赵耸耸肩。</p>
          <p class="dialogue k">"你刚才说01到05不知所踪，07在你这里，那CDD-06在哪儿？"</p>
          <p class="dialogue zhao">"理论上应该在The Foundation手里，但谁知道呢。不过我有个消息。艾莉娅曾说过她要前往一个'海底眼睛'。她当时要去见另一个有CDD的人。听起来像是那个新建的世界奇迹：'深渊突触枢纽'，连接香港和珠海的。"</p>
          <p>赵敲击着桌面。K若有所思地点点头。深渊突触枢纽，横跨珠江口的海底神经突触阵列，同时兼顾海底观光与光缆中继站，也是全球神经网络基础设施的关键节点。</p>
          <p class="dialogue zhao">"所以，我们做个交易如何？我知道你付不起我的服务费。你去那个母体，找回CDD-06，我就告诉你关于艾莉娅来询问的全部细节，以及一些我也不确定真伪的小道消息。"</p>
          <p>K思索了一会儿，然后站起身。</p>
          <p class="dialogue k">"如果信息没有用，到时候就不只是你的屁眼要担心了。"</p>
          <p>当K转身走向出口时，赵的声音从背后传来：</p>
          <p class="dialogue zhao">"别忘了，在不确定性的世界里，观察者会改变被观察的对象。小心你寻找的真相——它可能会回头寻找你。"</p>
      </div>

      <div class="section-divider transition">
          <span class="divider-icon">Ξ</span>
      </div>

      <!-- 海底场景 -->
      <div class="scene-title underwater" id="underwaterTitle">
          <h2>海底巨眼</h2>
      </div>

      <div class="story-segment underwater" id="segment5">
          <p>深渊突触枢纽是21世纪工程学的奇迹，不只是连接两座城市的物理通道，更是连接现实与数据领域的概念性桥梁。</p>
          <p>在神经网络与后量子理论基础上，枢纽允许信息以近乎零延迟的方式在物理与虚拟之间流动，创造出马克思曾经无法想象的生产关系——"数据"成为了新的生产力与生产资料。</p>
          <p>在这个过程中，人类主体性被悄然重构。</p>
          <p>TikTok的推荐算法平均每0.8秒调整用户画像，人们在信息茧房中形成世界观。2020后群体中78%的人认为"算法比我更懂自己"，笛卡尔"我思故我在"的命题也不复存在。</p>
      </div>

      <div class="story-segment underwater" id="segment6">
          <p>K站在海底隧道的观光区，透过厚重的钢化复合玻璃，能看到深海生物在黑暗中游弋，与忙碌闪烁的数据中心形成超现实对比。他的伪装很简单——一副合成丹宁镜片眼镜，一件皱巴巴的灰色西装，和一个印有"国际脑科学研讨会"标志的伪造证件。</p>
          <p class="dialogue k">"《基于深海头足类生物光量子突触的神经拓扑网络研究——兼论分布式意识在湍流介质中的传输衰减》"</p>
          <p>K小声念着幽灵0伪造的报告题目，心想他肯定是想做弄我，这里面就没有几个认识的词。</p>
          <p>证件检查站的AI甚至没多看他一眼，毕竟每周都有成百上千的科学家和工程师来参观这个奇迹，而且这个课题实在是——只有AI会喜欢的东西。</p>
          <p>进入主连接区后，K被眼前的景象震撼了。建筑结构遵循分形几何原理，每个舱室都是彭罗斯三角形的现实投影，在物理世界中创造出数学上"不可能"的空间。冷却液在透明管道中流淌，散发出梦幻般的荧光。</p>
          <p>当K走过某个扫描点时，周围的监控屏幕突然闪烁，出现了5帧他自己的记忆碎片——一个童年的秋千，妈妈模糊的面容。</p>
          <p class="dialogue k">"我肯定是太累了，2天没喝酒都产生幻觉了。"</p>
          <p>K对自己说。他的神经植入接收到幽灵0传来的地图。</p>
          <p>"根据能量扫描，有一个异常信息节点在C区7层。那里的数据流模式与常规处理不符，可能是某种特殊构造。"</p>
          <p>K跟随指示，避开主要人流，最终来到一扇标有特殊标识的厚重门前。门旁的安全面板显示需要A级权限才能进入。</p>
          <p class="dialogue k">"嗯？"</p>
          <p>K小声对幽灵0说。</p>
          <p>"30秒。"</p>
          <p>但随着时间流逝，K发现情况有些不对劲。这里太安静了，没有警卫，没有摄像头，整个区域似乎是一个安全盲点。如此先进的设施，不应该有这种疏漏。</p>
          <p class="dialogue k">"0，取消。这太简单了。"</p>
          <p>K突然警觉。</p>
          <p>"什么意思？"</p>
          <p class="dialogue k">"我是说，这感觉像个陷阱。"</p>
          <p>K环顾四周。</p>
          <p class="dialogue k">"没有防守，没有监控，就好像有人刻意让出一条通道。"</p><p>就在这时，门无声地滑开了。没有警报，没有安全协议。K握紧了口袋里的武器，小心翼翼地向前。</p>
        </div>

        <div class="story-segment underwater" id="segment7">
            <p>门后不是他预期的高安全实验室，而是一间舒适的会客室，设计风格介于未来主义与古典主义之间。</p>
            <p>房间中央，一个身材修长的英俊男子正站在全息数据流环绕的工作站前，手指在数据星云中编织着复杂的模式。</p>
            <p>他没有回头，声音平静而精确，口音一下定位到他至少在伦敦生活过十年以上。</p>
            <p class="dialogue marcus">"Krypt，你迟到了2分15秒。根据你的行为模式预测，你本应在14:52到达。"</p>
            <p>K警惕地将手放在武器上。</p>
            <p class="dialogue k">"你怎么知道我的名字？"</p>
            <p>男人终于转过身，镜面般的智能眼镜反射着数据流的光芒。</p>
            <p class="dialogue marcus">"我是Marcus，算法结构首席架构师。表面上，我拥有30%市面上所有社交产品的股权。但那只是掩护，就像你的科学家伪装一样。顺便说，那个帽子不适合你。"</p>
            <p>他微笑着。K没有理会他的调侃。</p>
            <p class="dialogue k">"你在等我？"</p>
            <p class="dialogue marcus">"是的，我计算过所有可能的概率路径。赵会把CDD-07展示给你看，会告诉你一些关于艾莉娅的事，而你——作为一个算法噪音制造者——会选择来这里调查。不存在潜入，Krypt，只有预期中的到访。"</p>
            <p class="dialogue k">"算法噪音制造者？"</p>
            <p>马库斯走向一旁的酒柜，为自己倒了一杯琥珀色的液体。</p>
            <p class="dialogue marcus">"你是个异数，Krypt。我们的预测模型对普通人的行为有98.7%的准确率，但对你只有77.4%。这很罕见，很有价值。"</p>
            <p>K的眼睛扫视着房间，寻找可能的陷阱或出口。</p>
            <p class="dialogue k">"你到底想要什么？"</p>
            <p class="dialogue marcus">"首先，我想向你证明一些事情。你想知道艾莉娅是否死了？答案是肯定的。3月14日02:17分，心脏骤停，死因记录为药物过量。"</p>
            <p>马库斯走向房间中央，激活了一个全息投影。</p>
            <p class="dialogue k">"为什么没有公开宣布？"</p>
            <p class="dialogue marcus">"因为艾莉娅对DID系统太重要了。市场、经济和社会稳定都需要她继续'活着'。"</p>
            <p>马库斯淡然道。</p>
            <p class="dialogue k">"所以那些广告，社交媒体更新..."</p>
            <p class="dialogue marcus">"这我不太关心，不过从我的知识结构，只要有基于她生前的数据样本，我可以以99%左右的准确率预测她会说什么，做什么，甚至思考什么。本质上，她的数字自我完全继续存在，而生物载体的消失只是个技术细节。"</p>
            <p>K握紧拳头。</p>
            <p class="dialogue k">"那出席这些活动的，在北海道滑雪的又是谁？如果你们都已经让她生物载体消失了？"</p>
            <p>这不是问句，而是陈述。马库斯的表情变得严肃。</p>
            <p class="dialogue marcus">"我们的组织通常不采取如此...直接的方法。杀人这种事，是比较低级的策略，不符合我们创立的初衷。但这个特例过于复杂。她看到了不该看到的东西。"</p>
            <p class="dialogue k">"什么东西？"</p>
            <p>马库斯拿起酒杯，轻轻晃动。</p>
            <p class="dialogue marcus">"这么对话挺没意思的，我想提出一个交易。一个游戏，你可以说。"</p>
            <p>他走向房间中央，地板突然变得透明，显示出下方复杂的神经网络模拟阵列。</p>
            <p class="dialogue marcus">"解开我的谜题，你就能得到CDD-06，以及关于艾莉娅的全部信息。"</p>
            <p>K怀疑地看着他。</p>
            <p class="dialogue k">"为什么要告诉我？这不符合你们的利益。"</p>
            <p class="dialogue marcus">"你不明白，Krypt。在信息的最高层面，没有'我们'和'你们'的区别。有的只是数据流、模式和异常。你是个有价值的异常，我想看看你是否能产生...有趣的观察角度。"</p>
        </div>

        <!-- 量子迷宫互动 -->
        <div class="quantum-maze-container" id="quantumMazeContainer">
            <canvas id="quantumMazeCanvas"></canvas>
        </div>

        <div class="story-segment underwater" id="segment8">
            <p>马库斯启动了房间中央的全息装置，投射出一个迷宫——空间几何不断重构的数据结构，在三维空间中扭曲、分叉、重组。</p>
            <p class="dialogue marcus">"这是概率态叠加的视觉表达。有64种可能的路径组合。每次尝试都会改变迷宫的结构。"</p>
            <p>他解释道。K看着不断变化的迷宫，试图找出规律。</p>
            <p class="dialogue k">"我怎么知道哪条路径是对的？"</p>
            <p class="dialogue marcus">"那正是谜题的核心。在不确定性原理中，'对'与'错'不再是截然二分的概念，而是概率分布的问题。可能性本身就是实在的一种形式。"</p>
            <p>马库斯的声音带着某种哲学意味。K尝试了几次，每次选择一条路径后，整个迷宫就会重构，这不是传统意义上的迷宫，而是对选择悖论的概念化表达。选择本身就改变了可能性的分布，使得确定性永远处于不确定的状态。</p>
            <p>在第七次失败后，K感到一阵挫折和愤怒。他猛地一拳打向全息投影，意外地，他的手穿过了所有路径，同时存在于64条可能路径上——迷宫突然冻结，然后像水晶一样碎裂。</p>
            <p>马库斯看起来既惊讶又欣赏。</p>
            <p class="dialogue marcus">"有趣。大多数人被困在选择的幻象中，而你——哪怕是出于愤怒——拒绝了这个框架本身。解决悖论的关键不是找到正确的路径，而是理解所有路径都正确。"</p>
            <p>马库斯走向墙边的保险柜，取出一个与赵展示的相似但纹路不同的十二面体。</p>
            <p class="dialogue marcus">"CDD-06，如约而至。你知道么，这是Foundation超临界实验室早期的产物，对我们来说—早就玩腻了。"</p>
            <p>K接过十二面体，感受到一种奇异的脉动，仿佛握住了一小片活的现实。</p>
            <p class="dialogue k">"现在告诉我关于艾莉娅的事。"</p>
            <p>马库斯摇头。</p>
            <p class="dialogue marcus">"知道答案和理解答案是两回事，我已经给了你钥匙，剩下的就是只有哪扇门的问题。"</p>
            <p>K注视着手中的CDD-06，表面开始浮现出图像——艾莉娅的容颜在多面体的各个面上闪烁，她的眼睛从每个角度直视K，瞳孔中蕴含着一种美丽的危险。</p>
        </div>

        <div class="section-divider">
            <span class="divider-icon">Ξ</span>
        </div>

        <div class="footnote">
            第二节：量子选择悖论 —— 完 <span class="xi-symbol">Ξ</span>
        </div>
        
        <!-- 底部导航 -->
        <div class="nav-buttons">
            <a href="digital-identity.html" class="prev-chapter-btn">
                <span class="prev-nav-icon">‹</span>
                <span class="nav-text">返回第一节</span>
            </a>
            <a href="reality-compilation-errors.html" class="next-chapter-btn">
                <span class="nav-text">继续访问下一数据碎片</span>
                <span class="nav-icon">›</span>
            </a>
        </div>
    </div>

    <!-- 添加Three.js和GSAP库 -->
    <script>if (typeof THREE === 'undefined') { document.write('<script src="/the-book-of-x-test/assets/js/three.min.js"><\/script>'); }</script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script>if (typeof gsap === 'undefined') { document.write('<script src="/the-book-of-x-test/assets/js/gsap.min.js"><\/script>'); }</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/ScrollTrigger.min.js"></script>
    <script>if (typeof ScrollTrigger === 'undefined') { document.write('<script src="/the-book-of-x-test/assets/js/ScrollTrigger.min.js"><\/script>'); }</script>

    <script>
        // 紧急键盘快捷键 - 按F或按空格显示全部内容
        document.addEventListener('keydown', function(e) {
            if (e.key === 'f' || e.key === 'F' || e.key === ' ') {
                window.showAllContent();
                
                // 显示快捷键提示
                const helpTip = document.createElement('div');
                helpTip.className = 'shortcut-help active';
                helpTip.textContent = '内容已强制显示';
                document.body.appendChild(helpTip);
                
                // 3秒后隐藏提示
                setTimeout(() => {
                    helpTip.style.display = 'none';
                }, 3000);
            }
        });
        
        // 确保页面滚动正常工作
        document.body.style.overflowY = 'auto';
        document.documentElement.style.overflowY = 'auto';
        
        // 库加载超时保障措施
        let librariesLoaded = false;
        let animationInitialized = false;
        
        // 检查库是否加载完成
        function checkLibraries() {
            if (typeof THREE !== 'undefined' && typeof gsap !== 'undefined' && typeof ScrollTrigger !== 'undefined') {
                librariesLoaded = true;
                return true;
            }
            return false;
        }
        
        // 30秒后的备用方案 - 无论库是否加载都显示内容
        setTimeout(() => {
            if (!librariesLoaded) {
                console.log('Libraries failed to load in time, activating backup display');
                document.body.classList.add('content-loaded');
                document.querySelector('.backup-loader').classList.add('active');
                document.querySelector('.backup-loader').textContent = '加载模式：兼容模式';
                
                // 确保入场动画不会阻挡内容
                const overlay = document.querySelector('.intro-overlay');
                if (overlay) {
                    overlay.style.display = 'none';
                }
                
                // 允许滚动
                document.body.style.overflow = 'auto';
                
                // 激活所有内容块
                document.querySelectorAll('.story-segment, .tech-briefing, .section-divider, .intro-card, .scene-title, .dodecahedron-container, .quantum-maze-container').forEach(el => {
                    el.classList.add('active');
                });
            }
        }, 30000);

        // 等待DOM加载完成
        document.addEventListener('DOMContentLoaded', function() {
            // 添加备用加载指示器
            const backupLoader = document.createElement('div');
            backupLoader.className = 'backup-loader';
            backupLoader.textContent = '加载中...';
            document.body.appendChild(backupLoader);
        
            // 开场动画
            setTimeout(() => {
                document.querySelector('.intro-overlay').classList.add('fade-out');
                document.querySelector('.scroll-indicator').classList.add('visible');
                
                // 确保在动画完成后初始化滚动动画和显示内容
                setTimeout(() => {
                    // 确保滚动初始化
                    document.body.style.overflow = 'auto';
                    
                    // 检查库加载状态并相应处理
                    if (checkLibraries()) {
                        // 初始化所有动画和交互
                    initScrollAnimations();
                    initThreeDodecahedron();
                    initQuantumMaze();
                    initParticleBackground();
                    createBubbles();
                    setupSceneTransitions();
                        
                        backupLoader.textContent = '加载模式：全功能';
                        backupLoader.classList.add('active');
                        setTimeout(() => backupLoader.classList.remove('active'), 3000);
                    } else {
                        console.log('Libraries not loaded correctly, using backup display');
                        document.body.classList.add('content-loaded');
                        backupLoader.textContent = '加载模式：基本模式';
                        backupLoader.classList.add('active');
                    }
                    
                    // 立即激活第一个可见块以确保内容可见
                    document.getElementById('introCard').classList.add('active');
                    
                    // 强制重新计算布局
                    window.dispatchEvent(new Event('resize'));
                    // 轻微滚动以触发滚动事件
                    window.scrollTo(0, 1);
                }, 2000);
            }, 3000); // 缩短入场动画时间以加快测试

            // 手动触发可见性转换功能 - 全局范围内也可调用
            function makeContentVisible() {
                document.querySelectorAll('.story-segment, .tech-briefing, .section-divider, .intro-card, .scene-title, .dodecahedron-container, .quantum-maze-container').forEach(el => {
                    if (isElementInViewport(el)) {
                        el.classList.add('active');
                        
                        // 处理段落内的元素
                        if (el.classList.contains('story-segment')) {
                            el.querySelectorAll('p').forEach(p => {
                                p.style.opacity = '1';
                                p.style.transform = 'translateY(0)';
                            });
                        }
                        
                        // 处理技术简报内的列表项
                        if (el.classList.contains('tech-briefing')) {
                            el.querySelectorAll('.tech-briefing-content li').forEach(item => {
                                item.style.opacity = '1';
                                item.style.transform = 'translateX(0)';
                            });
                        }
                    }
                });
            }
            
            // 检查元素是否在视口内 - 全局范围内也可调用
            function isElementInViewport(el) {
                const rect = el.getBoundingClientRect();
                return (
                    rect.top <= (window.innerHeight || document.documentElement.clientHeight) * 1.2 &&
                    rect.bottom >= -100
                );
            }
            
            // 全局紧急内容显示钩子 - 可以从浏览器控制台调用
            window.showAllContent = function() {
                document.body.classList.add('content-loaded');
                document.querySelectorAll('.story-segment, .tech-briefing, .section-divider, .intro-card, .scene-title, .dodecahedron-container, .quantum-maze-container').forEach(el => {
                    el.classList.add('active');
                    
                    // 处理段落内的元素
                    if (el.classList.contains('story-segment')) {
                        el.querySelectorAll('p').forEach(p => {
                            p.style.opacity = '1';
                            p.style.transform = 'translateY(0)';
                        });
                    }
                    
                    // 处理技术简报内的列表项
                    if (el.classList.contains('tech-briefing')) {
                        el.querySelectorAll('.tech-briefing-content li').forEach(item => {
                            item.style.opacity = '1'; 
                            item.style.transform = 'translateX(0)';
                        });
                    }
                });
                
                // 显示加载状态指示器
                const backupLoader = document.querySelector('.backup-loader');
                if (backupLoader) {
                    backupLoader.textContent = '加载模式：手动触发模式';
                    backupLoader.classList.add('active');
                }
                
                // 确保可以滚动
                document.body.style.overflowY = 'auto';
                document.documentElement.style.overflowY = 'auto';
                
                return '所有内容已显示';
            };

            // 滚动到顶部
            window.scrollTo(0, 0);

            // 处理滚动指示器和页面滚动事件
            window.addEventListener('scroll', function() {
                const scrollY = window.scrollY;
                
                // 当滚动超过一定值时隐藏滚动指示器
                if (scrollY > 300) {
                    document.querySelector('.scroll-indicator').classList.remove('visible');
                } else {
                    document.querySelector('.scroll-indicator').classList.add('visible');
                }

                // 检查和更新当前滚动位置的进度点
                updateProgressDots();
                
                // 手动检查元素可见性
                makeContentVisible();
            });

            // 为进度点添加点击事件
            document.querySelectorAll('.progress-dot').forEach(dot => {
                dot.addEventListener('click', function() {
                    const section = this.getAttribute('data-section');
                    scrollToSection(section);
                });
            });
            
            // 添加紧急滚动触发器
            document.querySelector('.scroll-indicator').addEventListener('click', function() {
                window.scrollTo({
                    top: document.getElementById('introCard').offsetTop,
                    behavior: 'smooth'
                });
                makeContentVisible();
            });
            
            // 双击任意位置进入兼容模式的紧急功能
            document.addEventListener('dblclick', function() {
                document.body.classList.add('content-loaded');
                const backupLoader = document.querySelector('.backup-loader');
                if (backupLoader) {
                    backupLoader.textContent = '加载模式：紧急模式';
                    backupLoader.classList.add('active');
                }
                window.showAllContent();
            });

            // 添加滚动事件的次级处理，以防主处理失效
            window.addEventListener('scroll', makeContentVisible);
            
            // 在页面加载后10秒检查是否有内容显示，如果没有则强制显示
            setTimeout(() => {
                const visibleElements = document.querySelectorAll('.story-segment.active, .tech-briefing.active, .intro-card.active');
                if (visibleElements.length === 0 && !animationInitialized) {
                    console.log('No visible content detected after timeout, forcing content display');
                    window.showAllContent();
                }
            }, 10000);
        });

        // 初始化滚动触发动画
        function initScrollAnimations() {
            // 标记动画已初始化
            animationInitialized = true;
            
            // 对入场动画覆盖层添加监听，确保动画结束后能够滚动
            const overlay = document.querySelector('.intro-overlay');
            if (overlay) {
                overlay.addEventListener('transitionend', function() {
                    document.body.style.overflowY = 'auto';
                    document.documentElement.style.overflowY = 'auto';
                    
                    // 触发初始可见性检查
                    makeContentVisible();
                    
                    // 强制显示第一个段落，以防其他机制失效
                    document.getElementById('introCard').classList.add('active');
                    
                    // 测试滚动，以确保滚动事件被触发
                    window.scrollTo(0, 1);
                    setTimeout(() => window.scrollTo(0, 0), 100);
                });
            }
            
            // 为每个故事段落添加滚动触发动画
            const storySegments = document.querySelectorAll('.story-segment, .tech-briefing, .section-divider, .intro-card, .scene-title, .dodecahedron-container, .quantum-maze-container');
            
            // 确保GSAP和ScrollTrigger已正确加载
            if (typeof gsap === 'undefined' || typeof ScrollTrigger === 'undefined') {
                console.error('GSAP or ScrollTrigger not loaded, falling back to basic animation');
                // 备用方案：如果GSAP未加载，使用简单的可见性切换
                storySegments.forEach(segment => {
                    segment.classList.add('active');
                    // 处理段落内元素的可见性
                    if (segment.classList.contains('story-segment')) {
                        segment.querySelectorAll('p').forEach(p => {
                            p.style.opacity = '1';
                            p.style.transform = 'translateY(0)';
                        });
                    }
                    if (segment.classList.contains('tech-briefing')) {
                        segment.querySelectorAll('.tech-briefing-content li').forEach(item => {
                            item.style.opacity = '1';
                            item.style.transform = 'translateX(0)';
                        });
                    }
                });
                return;
            }
            
            // 确保ScrollTrigger已注册
                gsap.registerPlugin(ScrollTrigger);
                
            storySegments.forEach((segment, index) => {
                ScrollTrigger.create({
                    trigger: segment,
                    start: "top 85%", // 略微提前触发点
                    onEnter: () => {
                        segment.classList.add('active');
                        // 为段落内的文本添加延迟出现动画
                        if (segment.classList.contains('story-segment')) {
                            const paragraphs = segment.querySelectorAll('p');
                            paragraphs.forEach((p, i) => {
                                p.style.transitionDelay = `${i * 150}ms`; // 加快过渡
                            });
                        }
                        
                        // 为技术简报内的列表项添加延迟出现动画
                        if (segment.classList.contains('tech-briefing')) {
                            const items = segment.querySelectorAll('.tech-briefing-content li');
                            items.forEach((item, i) => {
                                item.style.transitionDelay = `${i * 150}ms`; // 加快过渡
                            });
                        }
                    },
                    once: false // 允许重复触发以防止内容消失
                });
            });
        }

        // 3D十二面体FBX模型加载初始化
        function initThreeDodecahedron() {
            console.log("正在初始化3D模型...");
            const container = document.getElementById('dodecahedronContainer');
            if (!container) {
                console.error("找不到容器元素");
                return;
            }

            const canvas = document.getElementById('dodecahedronCanvas');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // 创建场景、相机和渲染器
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.z = 10;

            const renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: true
            });
            
            renderer.setSize(width, height);
            renderer.setClearColor(0x000000, 0);

            // 添加灯光
            const ambientLight = new THREE.AmbientLight(0x888888);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.6, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            const pointLight2 = new THREE.PointLight(0xfffae5, 0.4, 100);
            pointLight2.position.set(-10, -10, -10);
            scene.add(pointLight2);

            // 添加内部光源 - 蓝色
            const innerLight = new THREE.PointLight(0x00ccff, 2.0, 20);
            innerLight.position.set(0, 0, 0);
            scene.add(innerLight);

            // 加载过程中显示简单的占位十二面体
            const placeholderGeometry = new THREE.DodecahedronGeometry(3, 0);
            const placeholderMaterial = new THREE.MeshPhongMaterial({
                color: 0x111122,
                emissive: 0x3399ff,
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.5,
                wireframe: true
            });
            const placeholder = new THREE.Mesh(placeholderGeometry, placeholderMaterial);
            scene.add(placeholder);
            
            // 创建控制器
            const controls = new THREE.OrbitControls(camera, canvas);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // 加载FBX模型
            const modelPath = '/assets/3D/一个镂空的正十二面体fbx/一个镂空的正十_0324014923_texture.fbx';
            const texturePath = '/assets/3D/一个镂空的正十二面体fbx/一个镂空的正十_0324014923_texture.png';
            const loader = new THREE.FBXLoader();
            let fbxModel;
            
            console.log("开始加载FBX模型:", modelPath);
            // 尝试使用encodeURI处理路径
            const encodedModelPath = encodeURI(modelPath);
            const encodedTexturePath = encodeURI(texturePath);
            
            console.log("编码后的路径:", encodedModelPath);
            
            loader.load(
                encodedModelPath,
                (object) => {
                    console.log("FBX模型加载成功", object);
                    fbxModel = object;
                    // 移除占位十二面体
                    scene.remove(placeholder);
                    
                    // 调整模型大小和位置
                    fbxModel.scale.set(0.02, 0.02, 0.02);
                    fbxModel.position.set(0, 0, 0);
                    
                    // 添加玻璃边框效果
                    const bbox = new THREE.Box3().setFromObject(fbxModel);
                    const size = new THREE.Vector3();
                    bbox.getSize(size);
                    
                    const borderGeometry = new THREE.BoxGeometry(size.x * 1.15, size.y * 1.15, size.z * 1.15);
                    
                    // 创建玻璃材质
                    const glassMaterial = new THREE.MeshPhysicalMaterial({
                        color: 0x66ccff,
                transparent: true,
                        opacity: 0.15,
                        roughness: 0.1,
                        metalness: 0.1,
                        reflectivity: 0.5,
                        clearcoat: 0.5,
                        clearcoatRoughness: 0.1,
                        side: THREE.DoubleSide
                    });
                    const borderGlass = new THREE.Mesh(borderGeometry, glassMaterial);
                    
                    // 保留线框边缘
                    const borderEdges = new THREE.EdgesGeometry(borderGeometry);
                    const edgeMaterial = new THREE.LineBasicMaterial({
                        color: 0x66ccff,
                        transparent: true,
                        opacity: 0.4
                    });
                    const borderLines = new THREE.LineSegments(borderEdges, edgeMaterial);
                    
                    // 加载纹理
                    const textureLoader = new THREE.TextureLoader();
                    textureLoader.load(
                        encodedTexturePath,
                        (texture) => {
                            console.log("纹理加载成功");
                            // 应用纹理到模型所有部分
                            fbxModel.traverse((child) => {
                                if (child.isMesh) {
                                    child.material.map = texture;
                                    child.material.transparent = true;
                                    child.material.opacity = 0.9;
                                    // 添加内发光效果
                                    child.material.emissive = new THREE.Color(0x2288ff);
                                    child.material.emissiveIntensity = 0.6;
                                    child.material.needsUpdate = true;
                                }
                            });
                            
                            scene.add(fbxModel);
                            scene.add(borderGlass);
                            scene.add(borderLines);
                        },
                        undefined, // 进度回调
                        (error) => {
                            console.error("纹理加载失败:", error);
                            // 即使没有纹理也添加模型
                            scene.add(fbxModel);
                            scene.add(borderGlass);
                            scene.add(borderLines);
                        }
                    );
                },
                (xhr) => {
                    // 加载进度
                    const percent = Math.floor((xhr.loaded / xhr.total) * 100);
                    console.log(`模型加载进度: ${percent}%`);
                },
                (error) => {
                    console.error("FBX模型加载失败:", error);
                    // 尝试使用相对路径
                    const relativePath = '../../assets/3D/一个镂空的正十二面体fbx/一个镂空的正十_0324014923_texture.fbx';
                    console.log("尝试使用相对路径:", relativePath);
                    
                    // 对相对路径同样进行编码
                    const encodedRelativePath = encodeURI(relativePath);
                    console.log("编码后的相对路径:", encodedRelativePath);
                    
                    loader.load(
                        encodedRelativePath,
                        (object) => {
                            console.log("使用相对路径加载成功");
                            fbxModel = object;
                            scene.remove(placeholder);
                            
                            fbxModel.scale.set(0.02, 0.02, 0.02);
                            fbxModel.position.set(0, 0, 0);
                            
                            const bbox = new THREE.Box3().setFromObject(fbxModel);
                            const size = new THREE.Vector3();
                            bbox.getSize(size);
                            
                            const borderGeometry = new THREE.BoxGeometry(size.x * 1.15, size.y * 1.15, size.z * 1.15);
                            
                            // 创建玻璃材质
                            const glassMaterial = new THREE.MeshPhysicalMaterial({
                                color: 0x66ccff,
                                transparent: true,
                                opacity: 0.15,
                                roughness: 0.1,
                                metalness: 0.1,
                                reflectivity: 0.5,
                                clearcoat: 0.5,
                                clearcoatRoughness: 0.1,
                                side: THREE.DoubleSide
                            });
                            const borderGlass = new THREE.Mesh(borderGeometry, glassMaterial);
                            
                            // 保留线框边缘
                            const borderEdges = new THREE.EdgesGeometry(borderGeometry);
                            const edgeMaterial = new THREE.LineBasicMaterial({
                                color: 0x66ccff,
                                transparent: true,
                                opacity: 0.4
                            });
                            const borderLines = new THREE.LineSegments(borderEdges, edgeMaterial);
                            
                            // 加载纹理 - 相对路径
                            const relativeTexturePath = '../../assets/3D/一个镂空的正十二面体fbx/一个镂空的正十_0324014923_texture.png';
                            const encodedRelativeTexturePath = encodeURI(relativeTexturePath);
                            const textureLoader = new THREE.TextureLoader();
                            textureLoader.load(
                                encodedRelativeTexturePath,
                                (texture) => {
                                    fbxModel.traverse((child) => {
                                        if (child.isMesh) {
                                            child.material.map = texture;
                                            child.material.transparent = true;
                                            child.material.opacity = 0.9;
                                            // 添加内发光效果
                                            child.material.emissive = new THREE.Color(0x2288ff);
                                            child.material.emissiveIntensity = 0.6;
                                            child.material.needsUpdate = true;
                                        }
                                    });
                                    
                                    scene.add(fbxModel);
                                    scene.add(borderGlass);
                                    scene.add(borderLines);
                                },
                                undefined,
                                (error) => {
                                    console.error("纹理加载失败(相对路径):", error);
                                    scene.add(fbxModel);
                                    scene.add(borderLines);
                                }
                            );
                        },
                        (xhr) => {
                            const percent = Math.floor((xhr.loaded / xhr.total) * 100);
                            console.log(`相对路径加载进度: ${percent}%`);
                        },
                        (error) => {
                            console.error("两种路径都无法加载FBX:", error);
                            // 保留占位符
                        }
                    );
                }
            );

            // 动画循环
            function animate() {
                requestAnimationFrame(animate);
                
                if (placeholder) {
                    placeholder.rotation.x += 0.005;
                    placeholder.rotation.y += 0.01;
                }
                
                if (fbxModel) {
                    fbxModel.rotation.y += 0.005;
                }
                
                controls.update();
                renderer.render(scene, camera);
            }
            
            animate();

            // 处理窗口大小变化
            window.addEventListener('resize', () => {
                const newWidth = container.clientWidth;
                const newHeight = container.clientHeight;
                
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                
                renderer.setSize(newWidth, newHeight);
            });
        }

        // 量子迷宫初始化
        function initQuantumMaze() {
            const container = document.getElementById('quantumMazeContainer');
            if (!container) return;

            const canvas = document.getElementById('quantumMazeCanvas');
            const ctx = canvas.getContext('2d');
            
            // 设置canvas大小
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            // 迷宫参数
            const cellSize = 40;
            const cols = Math.floor(canvas.width / cellSize);
            const rows = Math.floor(canvas.height / cellSize);
            
            // 粒子系统
            const particles = [];
            const particleCount = 200;
            
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 3 + 1,
                    color: `rgba(${Math.random() * 100 + 100}, ${Math.random() * 100}, ${Math.random() * 255}, ${Math.random() * 0.5 + 0.2})`,
                    speed: Math.random() * 2 + 0.5,
                    angle: Math.random() * Math.PI * 2
                });
            }
            
            // 迷宫生成
            function generateMaze() {
                const maze = new Array(cols).fill().map(() => new Array(rows).fill(0));
                
                // 随机填充一些墙
                for (let x = 0; x < cols; x++) {
                    for (let y = 0; y < rows; y++) {
                        if (Math.random() < 0.25) {
                            maze[x][y] = 1;
                        }
                    }
                }
                
                return maze;
            }
            
            let maze = generateMaze();
            let lastUpdateTime = 0;
            const updateInterval = 2000; // 每2秒重新生成迷宫
            
            // 绘制函数
            function draw(timestamp) {
                // 清除画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 检查是否需要更新迷宫
                if (timestamp - lastUpdateTime > updateInterval) {
                    maze = generateMaze();
                    lastUpdateTime = timestamp;
                }
                
                // 绘制迷宫
                for (let x = 0; x < cols; x++) {
                    for (let y = 0; y < rows; y++) {
                        if (maze[x][y] === 1) {
                            const probability = (timestamp % updateInterval) / updateInterval;
                            const alpha = 0.3 + (1 - probability) * 0.5;
                            
                            ctx.fillStyle = `rgba(0, 136, 255, ${alpha})`;
                            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                            
                            // 添加发光效果
                            ctx.shadowColor = '#00bfff';
                            ctx.shadowBlur = 15;
                            ctx.strokeStyle = `rgba(0, 180, 255, ${alpha})`;
                            ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                            ctx.shadowBlur = 0;
                        }
                    }
                }
                
                // 更新和绘制粒子
                particles.forEach(particle => {
                    // 更新位置
                    particle.x += Math.cos(particle.angle) * particle.speed;
                    particle.y += Math.sin(particle.angle) * particle.speed;
                    
                    // 边界检查
                    if (particle.x < 0 || particle.x > canvas.width || 
                        particle.y < 0 || particle.y > canvas.height) {
                        particle.angle = Math.random() * Math.PI * 2;
                        
                        // 重新放置在边缘
                        if (Math.random() < 0.5) {
                            particle.x = Math.random() < 0.5 ? 0 : canvas.width;
                            particle.y = Math.random() * canvas.height;
                        } else {
                            particle.x = Math.random() * canvas.width;
                            particle.y = Math.random() < 0.5 ? 0 : canvas.height;
                        }
                    }
                    
                    // 绘制粒子
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    ctx.fillStyle = particle.color;
                    ctx.fill();
                });
                
                // 添加波浪效果
                const time = timestamp / 1000;
                
                ctx.beginPath();
                for (let x = 0; x < canvas.width; x += 5) {
                    const y = Math.sin(x * 0.01 + time) * 10 + canvas.height / 2;
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                requestAnimationFrame(draw);
            }
            
            // 开始动画
            requestAnimationFrame(draw);
            
            // 处理窗口大小变化
            window.addEventListener('resize', () => {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            });
        }

        // 初始化粒子背景
        function initParticleBackground() {
            const container = document.getElementById('particles-container');
            if (!container) return;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            container.appendChild(canvas);
            
            // 设置canvas大小
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // 粒子系统
            const particles = [];
            const particleCount = 100;
            
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 2 + 0.5,
                    color: `rgba(${Math.random() * 100 + 155}, ${Math.random() * 100 + 155}, ${Math.random() * 255}, ${Math.random() * 0.5 + 0.1})`,
                    speed: Math.random() * 0.5 + 0.1,
                    angle: Math.random() * Math.PI * 2,
                    directionChangeSpeed: Math.random() * 0.001 + 0.0005
                });
            }
            
            // 绘制函数
            function draw(timestamp) {
                // 清除画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 更新和绘制粒子
                particles.forEach(particle => {
                    // 逐渐改变方向
                    particle.angle += (Math.random() - 0.5) * particle.directionChangeSpeed;
                    
                    // 更新位置
                    particle.x += Math.cos(particle.angle) * particle.speed;
                    particle.y += Math.sin(particle.angle) * particle.speed;
                    
                    // 边界检查
                    if (particle.x < 0) particle.x = canvas.width;
                    if (particle.x > canvas.width) particle.x = 0;
                    if (particle.y < 0) particle.y = canvas.height;
                    if (particle.y > canvas.height) particle.y = 0;
                    
                    // 绘制粒子
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    ctx.fillStyle = particle.color;
                    ctx.fill();
                });
                
                // 连接近距离的粒子
                const connectionDistance = 150;
                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < connectionDistance) {
                            ctx.beginPath();
                            ctx.strokeStyle = `rgba(255, 255, 255, ${(1 - distance / connectionDistance) * 0.15})`;
                            ctx.moveTo(particles[i].x, particles[i].y);
                            ctx.lineTo(particles[j].x, particles[j].y);
                            ctx.stroke();
                        }
                    }
                }
                
                requestAnimationFrame(draw);
            }
            
            // 开始动画
            requestAnimationFrame(draw);
            
            // 处理窗口大小变化
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        }

        // 创建海底泡泡效果
        function createBubbles() {
            const bubblesContainer = document.getElementById('bubblesContainer');
            if (!bubblesContainer) return;
            
            const bubbleCount = 30;
            
            for (let i = 0; i < bubbleCount; i++) {
                const bubble = document.createElement('div');
                bubble.classList.add('bubble');
                
                // 设置随机大小
                const size = Math.random() * 30 + 5;
                bubble.style.width = `${size}px`;
                bubble.style.height = `${size}px`;
                
                // 设置随机位置
                const posX = Math.random() * 100;
                bubble.style.left = `${posX}%`;
                
                // 设置随机动画持续时间
                const duration = Math.random() * 10 + 8;
                bubble.style.animationDuration = `${duration}s`;
                
                // 设置随机延迟
                const delay = Math.random() * 10;
                bubble.style.animationDelay = `${delay}s`;
                
                bubblesContainer.appendChild(bubble);
            }
        }

        // 设置场景转场
        function setupSceneTransitions() {
            // 获取各个场景元素
            const blackMarketTitle = document.getElementById('blackMarketTitle');
            const underwaterTitle = document.getElementById('underwaterTitle');
            const neonGrid = document.querySelector('.neon-grid');
            const bubblesContainer = document.getElementById('bubblesContainer');
            const depthGauge = document.querySelector('.depth-gauge');
            
            // 注册滚动触发器
            gsap.registerPlugin(ScrollTrigger);
            
            // 黑市场景
            ScrollTrigger.create({
                trigger: blackMarketTitle,
                start: "top 80%",
                onEnter: () => {
                    // 更改背景色和网格
                    document.body.style.backgroundColor = 'var(--bg-black-market)';
                    neonGrid.style.backgroundImage = `
                        linear-gradient(to right, rgba(255, 51, 102, 0.05) 1px, transparent 1px),
                        linear-gradient(to bottom, rgba(255, 51, 102, 0.05) 1px, transparent 1px)
                    `;
                    
                    // 隐藏海底元素
                    bubblesContainer.style.visibility = 'hidden';
                    bubblesContainer.style.opacity = '0';
                    depthGauge.classList.remove('active');
                    
                    // 重置深度计的值
                    document.querySelector('.depth-bar').style.height = '0%';
                    document.querySelector('.depth-value').innerText = '0m';
                },
                once: false
            });
            
            // 海底场景
            ScrollTrigger.create({
                trigger: underwaterTitle,
                start: "top 80%",
                onEnter: () => {
                    // 显示转场动画
                    const transition = document.querySelector('.scene-transition');
                    transition.classList.add('active');
                    
                    setTimeout(() => {
                        // 更改背景色和网格
                        document.body.style.backgroundColor = 'var(--bg-underwater)';
                        neonGrid.style.backgroundImage = `
                            linear-gradient(to right, rgba(0, 136, 255, 0.05) 1px, transparent 1px),
                            linear-gradient(to bottom, rgba(0, 136, 255, 0.05) 1px, transparent 1px)
                        `;
                        
                        // 显示海底元素
                        bubblesContainer.style.visibility = 'visible';
                        bubblesContainer.style.opacity = '1';
                        depthGauge.classList.add('active');
                        
                        // 动画深度计
                        setTimeout(() => {
                            document.querySelector('.depth-bar').style.height = '70%';
                            document.querySelector('.depth-value').innerText = '2,140m';
                        }, 1000);
                        
                        // 隐藏转场动画
                        transition.classList.remove('active');
                    }, 1000);
                },
                once: false
            });
            
            // 返回到普通场景
            ScrollTrigger.create({
                trigger: '.footnote',
                start: "top 80%",
                onEnter: () => {
                    // 恢复背景色和网格
                    document.body.style.backgroundColor = 'var(--bg-primary)';
                    neonGrid.style.backgroundImage = `
                        linear-gradient(to right, rgba(0, 255, 157, 0.05) 1px, transparent 1px),
                        linear-gradient(to bottom, rgba(0, 255, 157, 0.05) 1px, transparent 1px)
                    `;
                    
                    // 隐藏海底元素
                    bubblesContainer.style.visibility = 'hidden';
                    bubblesContainer.style.opacity = '0';
                    depthGauge.classList.remove('active');
                },
                once: false
            });
        }

        // 更新进度点
        function updateProgressDots() {
            // 获取各节点
            const introCard = document.getElementById('introCard');
            const blackMarketTitle = document.getElementById('blackMarketTitle');
            const underwaterTitle = document.getElementById('underwaterTitle');
            const quantumMazeContainer = document.getElementById('quantumMazeContainer');
            const footnote = document.querySelector('.footnote');
            
            // 获取滚动位置
            const scrollPosition = window.pageYOffset + window.innerHeight / 2;
            
            // 移除所有激活状态
            document.querySelectorAll('.progress-dot').forEach(dot => {
                dot.classList.remove('active');
            });
            
            // 根据当前位置激活对应点
            if (introCard && scrollPosition >= introCard.offsetTop && scrollPosition < blackMarketTitle.offsetTop) {
                document.querySelector('.progress-dot[data-section="intro"]').classList.add('active');
            } else if (blackMarketTitle && scrollPosition >= blackMarketTitle.offsetTop && scrollPosition < underwaterTitle.offsetTop) {
                document.querySelector('.progress-dot[data-section="black-market"]').classList.add('active');
            } else if (underwaterTitle && scrollPosition >= underwaterTitle.offsetTop && scrollPosition < quantumMazeContainer.offsetTop) {
                document.querySelector('.progress-dot[data-section="underwater"]').classList.add('active');
            } else if (quantumMazeContainer && scrollPosition >= quantumMazeContainer.offsetTop && scrollPosition < footnote.offsetTop) {
                document.querySelector('.progress-dot[data-section="quantum-maze"]').classList.add('active');
            } else if (footnote && scrollPosition >= footnote.offsetTop) {
                document.querySelector('.progress-dot[data-section="ending"]').classList.add('active');
            }
        }

        // 滚动到指定节点
        function scrollToSection(section) {
            let targetElement;
            
            switch(section) {
                case 'intro':
                    targetElement = document.getElementById('introCard');
                    break;
                case 'black-market':
                    targetElement = document.getElementById('blackMarketTitle');
                    break;
                case 'underwater':
                    targetElement = document.getElementById('underwaterTitle');
                    break;
                case 'quantum-maze':
                    targetElement = document.getElementById('quantumMazeContainer');
                    break;
                case 'ending':
                    targetElement = document.querySelector('.footnote');
                    break;
                default:
                    return;
            }
            
            if (targetElement) {
                // 显示转场动画
                const transition = document.querySelector('.scene-transition');
                transition.classList.add('active');
                
                setTimeout(() => {
                    // 滚动到目标位置
                    window.scrollTo({
                        top: targetElement.offsetTop - 50,
                        behavior: 'auto'
                    });
                    
                    // 隐藏转场动画
                    setTimeout(() => {
                        transition.classList.remove('active');
                    }, 500);
                }, 500);
            }
        }

        // 侧边栏功能
        document.addEventListener('DOMContentLoaded', function() {
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const mainContent = document.querySelector('.container');
            
            if (sidebar && sidebarToggle) {
                console.log('侧边栏元素已找到，初始化事件...');
                
                // 切换侧边栏
                sidebarToggle.addEventListener('click', function() {
                    console.log('切换侧边栏');
                    sidebar.classList.toggle('active');
                    if (mainContent) {
                        if (sidebar.classList.contains('active')) {
                            mainContent.classList.add('sidebar-active');
                        } else {
                            mainContent.classList.remove('sidebar-active');
                        }
                    }
                });
                
                // 点击侧边栏外关闭侧边栏
                document.addEventListener('click', function(e) {
                    if (sidebar.classList.contains('active') && 
                        !sidebar.contains(e.target) && 
                        e.target !== sidebarToggle &&
                        !sidebarToggle.contains(e.target)) {
                        sidebar.classList.remove('active');
                        if (mainContent) {
                            mainContent.classList.remove('sidebar-active');
                        }
                    }
                });
                
                // 高亮当前页面链接
                const currentUrl = window.location.pathname;
                const links = sidebar.querySelectorAll('a');
                links.forEach(link => {
                    const linkPath = link.getAttribute('href');
                    if (currentUrl.endsWith(linkPath) || 
                        (currentUrl.includes('/chapter2/quantum-choice-paradox') && linkPath.includes('/chapter2/quantum-choice-paradox'))) {
                        link.style.color = '#00ff9d';
                        link.style.fontWeight = 'bold';
                    }
                });
            }
            

        });

        // 初始化函数
        document.addEventListener('DOMContentLoaded', function() {
            createBreadcrumbLinks();
            setupScrollAnimations();
            initQuantumMaze();
            setupCardReveal();
            initBackgroundParticles();
        });

        // 设置页面滚动动画
        function setupScrollAnimations() {
            // 添加滚动动画
            document.querySelectorAll('.story-segment, .tech-briefing, .terminal-output').forEach(element => {
                IntersectionObserver.observe(element, {
                    threshold: 0.2,
                    callback: entries => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                entry.target.classList.add('active');
                                
                                // 对于技术简报，逐项显示列表项
                                if (entry.target.classList.contains('tech-briefing')) {
                                    const items = entry.target.querySelectorAll('.tech-briefing-content li');
                                    items.forEach((item, i) => {
                                        item.style.transitionDelay = `${i * 150}ms`; // 加快过渡
                                    });
                                }
                            }
                        });
                    },
                    once: false // 允许重复触发以防止内容消失
                });
            });
        }

        // 量子迷宫初始化
        function initQuantumMaze() {
            const container = document.getElementById('quantumMazeContainer');
            if (!container) return;

            const canvas = document.getElementById('quantumMazeCanvas');
            const ctx = canvas.getContext('2d');
            
            // 设置canvas大小
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            // 迷宫参数
            const cellSize = 40;
            const cols = Math.floor(canvas.width / cellSize);
            const rows = Math.floor(canvas.height / cellSize);
            
            // 粒子系统
            const particles = [];
            const particleCount = 200;
            
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 3 + 1,
                    color: `rgba(${Math.random() * 100 + 100}, ${Math.random() * 100}, ${Math.random() * 255}, ${Math.random() * 0.5 + 0.2})`,
                    speed: Math.random() * 2 + 0.5,
                    angle: Math.random() * Math.PI * 2
                });
            }
            
            // 迷宫生成
            function generateMaze() {
                const maze = new Array(cols).fill().map(() => new Array(rows).fill(0));
                
                // 随机填充一些墙
                for (let x = 0; x < cols; x++) {
                    for (let y = 0; y < rows; y++) {
                        if (Math.random() < 0.25) {
                            maze[x][y] = 1;
                        }
                    }
                }
                
                return maze;
            }
            
            let maze = generateMaze();
            let lastUpdateTime = 0;
            const updateInterval = 2000; // 每2秒重新生成迷宫
            
            // 绘制函数
            function draw(timestamp) {
                // 清除画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 检查是否需要更新迷宫
                if (timestamp - lastUpdateTime > updateInterval) {
                    maze = generateMaze();
                    lastUpdateTime = timestamp;
                }
                
                // 绘制迷宫
                for (let x = 0; x < cols; x++) {
                    for (let y = 0; y < rows; y++) {
                        if (maze[x][y] === 1) {
                            const probability = (timestamp % updateInterval) / updateInterval;
                            const alpha = 0.3 + (1 - probability) * 0.5;
                            
                            ctx.fillStyle = `rgba(0, 136, 255, ${alpha})`;
                            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                            
                            // 添加发光效果
                            ctx.shadowColor = '#00bfff';
                            ctx.shadowBlur = 15;
                            ctx.strokeStyle = `rgba(0, 180, 255, ${alpha})`;
                            ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                            ctx.shadowBlur = 0;
                        }
                    }
                }
                
                // 更新和绘制粒子
                particles.forEach(particle => {
                    // 更新位置
                    particle.x += Math.cos(particle.angle) * particle.speed;
                    particle.y += Math.sin(particle.angle) * particle.speed;
                    
                    // 边界检查
                    if (particle.x < 0 || particle.x > canvas.width || 
                        particle.y < 0 || particle.y > canvas.height) {
                        particle.angle = Math.random() * Math.PI * 2;
                        
                        // 重新放置在边缘
                        if (Math.random() < 0.5) {
                            particle.x = Math.random() < 0.5 ? 0 : canvas.width;
                            particle.y = Math.random() * canvas.height;
                        } else {
                            particle.x = Math.random() * canvas.width;
                            particle.y = Math.random() < 0.5 ? 0 : canvas.height;
                        }
                    }
                    
                    // 绘制粒子
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    ctx.fillStyle = particle.color;
                    ctx.fill();
                });
                
                // 添加波浪效果
                const time = timestamp / 1000;
                
                ctx.beginPath();
                for (let x = 0; x < canvas.width; x += 5) {
                    const y = Math.sin(x * 0.01 + time) * 10 + canvas.height / 2;
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                requestAnimationFrame(draw);
            }
            
            // 开始动画
            requestAnimationFrame(draw);
            
            // 处理窗口大小变化
            window.addEventListener('resize', () => {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            });
        }
    </script>
    
    <!-- 额外的Three.js插件脚本 -->

    <!-- 侧边栏JavaScript代码 -->
    <script src="../../sidebar.js"></script>
    
    <!-- 添加XiCore音乐播放器引用 -->
    <script>
    document.addEventListener("DOMContentLoaded", function() {
      // 检测是否为本地环境
      const isLocalhost = window.location.hostname === 'localhost' || 
                         window.location.hostname === '127.0.0.1';
      
      // 根据环境选择正确的路径
      const xiMusicPath = isLocalhost ? 
          '../XiCore/modules/xi-music.js' : 
          '/the-book-of-x-test/XiCore/modules/xi-music.js';
      
      // 加载XiMusic模块
      const script = document.createElement("script");
      script.src = xiMusicPath;
      script.onload = function() {
        if (window.XiMusic) {
          console.log("正在初始化XiMusic播放器...");
          XiMusic.init();
        }
      };
      script.onerror = function() {
        console.error("XiMusic模块加载失败，尝试备用路径...");
        const backupScript = document.createElement("script");
        backupScript.src = isLocalhost ? "/XiCore/modules/xi-music.js" : "/XiCore/modules/xi-music.js";
        backupScript.onload = function() {
          if (window.XiMusic) XiMusic.init();
        };
        document.head.appendChild(backupScript);
      };
      document.head.appendChild(script);
    });
    </script>
</body>
</html>